<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processing Pipeline Dashboard</title>
    <style>
        body { font-family: sans-serif; margin: 20px; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .stages-list { list-style: none; padding: 0; margin: 0; }
        .stages-list li { display: inline-block; margin-right: 5px; padding: 2px 5px; background-color: #e7e7e7; border-radius: 3px; font-size: 0.9em; }
        .reset-button { margin-left: 5px; cursor: pointer; color: red; font-size: 0.8em; }
        #refresh-button { margin-bottom: 20px; padding: 10px 15px; cursor: pointer; }
        #status-message { margin-top: 10px; font-style: italic; }
        #loading-indicator { display: none; }
        #filter-input { margin-left: 10px; padding: 5px; }
    </style>
</head>
<body>
    <h1>Processing Pipeline Status</h1>

    <button id="refresh-button">Refresh Status</button>
    <label for="filter-input">Filter by name:</label>
    <input type="text" id="filter-input" placeholder="Enter filename part...">
    <span id="loading-indicator">Loading...</span>
    <div id="status-message"></div>

    <table id="status-table">
        <thead>
            <tr>
                <th>Filename</th>
                <th>Title</th>
                <th>Category</th>
                <th>Date</th>
                <th>Processing Stages</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            <!-- Data will be loaded here by JavaScript -->
        </tbody>
    </table>

    <script>
        const tableBody = document.querySelector('#status-table tbody');
        const refreshButton = document.getElementById('refresh-button');
        const statusMessage = document.getElementById('status-message');
        const loadingIndicator = document.getElementById('loading-indicator');
        const filterInput = document.getElementById('filter-input');
        let fullStatusData = {}; // Store the full dataset for filtering

        function renderTable(data) {
            tableBody.innerHTML = ''; // Clear existing rows
            const filterText = filterInput.value.toLowerCase();

            // Sort filenames alphabetically for consistent display
            const sortedFilenames = Object.keys(data).sort();

            sortedFilenames.forEach(filename => {
                if (filterText && !filename.toLowerCase().includes(filterText)) {
                    return; // Skip if filter doesn't match
                }

                const fileData = data[filename];
                const row = tableBody.insertRow();

                row.insertCell().textContent = filename;
                row.insertCell().textContent = fileData.title || '';
                row.insertCell().textContent = fileData.category || 'unknown';
                row.insertCell().textContent = fileData.date || '';

                // Processing Stages
                const stagesCell = row.insertCell();
                const stagesList = document.createElement('ul');
                stagesList.className = 'stages-list';
                (fileData.processing_stages || []).forEach(stageInfo => {
                    const stageItem = document.createElement('li');
                    stageItem.textContent = stageInfo.name;
                    // Add reset button per stage ONLY if resettable
                    if (stageInfo.resettable) {
                        const resetButton = document.createElement('span');
                        resetButton.textContent = '❌'; // Use text or an icon
                        resetButton.className = 'reset-button';
                        resetButton.title = `Reset stage '${stageInfo.name}'`;
                        resetButton.onclick = () => resetStage(filename, stageInfo.name);
                        stageItem.appendChild(resetButton);
                    }

                    stagesList.appendChild(stageItem);
                });
                stagesCell.appendChild(stagesList);

                 // Actions Cell (e.g., for overall reset or other actions)
                 const actionsCell = row.insertCell();
                 // Example: Add a button to reset ALL stages for this file
                 // const resetAllButton = document.createElement('button');
                 // resetAllButton.textContent = 'Reset All';
                 // resetAllButton.onclick = () => { /* Add logic if needed */ };
                 // actionsCell.appendChild(resetAllButton);
            });
        }

        async function fetchStatus() {
            loadingIndicator.style.display = 'inline';
            statusMessage.textContent = 'Fetching status...';
            try {
                const response = await fetch('/api/status');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                fullStatusData = await response.json();
                renderTable(fullStatusData);
                statusMessage.textContent = `Status loaded. ${Object.keys(fullStatusData).length} files indexed.`;
            } catch (error) {
                console.error('Error fetching status:', error);
                statusMessage.textContent = `Error fetching status: ${error.message}`;
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        async function triggerRefresh() {
            loadingIndicator.style.display = 'inline';
            refreshButton.disabled = true;
            statusMessage.textContent = 'Refreshing index (this may take a while)...';
            try {
                const response = await fetch('/api/refresh-status', { method: 'POST' });
                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || `HTTP error! status: ${response.status}`);
                }
                statusMessage.textContent = result.message || 'Refresh initiated.';
                // Fetch the updated status after refresh
                await fetchStatus();
            } catch (error) {
                console.error('Error triggering refresh:', error);
                statusMessage.textContent = `Error refreshing status: ${error.message}`;
            } finally {
                loadingIndicator.style.display = 'none';
                refreshButton.disabled = false;
            }
        }

        async function resetStage(filename, stageName) {
            if (!confirm(`Are you sure you want to reset stage '${stageName}' for file '${filename}'?`)) {
                return;
            }

            loadingIndicator.style.display = 'inline';
            statusMessage.textContent = `Resetting stage '${stageName}' for ${filename}...`;

            try {
                const response = await fetch('/api/reset-stage', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filename: filename, stage_name: stageName })
                });
                const result = await response.json();
                 if (!response.ok) {
                    throw new Error(result.error || `HTTP error! status: ${response.status}`);
                }
                statusMessage.textContent = result.message || `Stage '${stageName}' reset for ${filename}.`;
                // For simplicity, let's update the local data and re-render
                if (fullStatusData[filename] && fullStatusData[filename].processing_stages) {
                    // Find the stage object and remove it
                    fullStatusData[filename].processing_stages = fullStatusData[filename].processing_stages.filter(
                        stageInfo => stageInfo.name !== stageName
                    );
                    renderTable(fullStatusData); // Re-render with updated local data
                } else {
                     await fetchStatus(); // Refetch if local data is inconsistent
                }

            } catch (error) {
                console.error('Error resetting stage:', error);
                statusMessage.textContent = `Error resetting stage: ${error.message}`;
                 // Optionally refetch status on error to ensure consistency
                 await fetchStatus();
            } finally {
                 loadingIndicator.style.display = 'none';
            }
        }

        // Event Listeners
        refreshButton.addEventListener('click', triggerRefresh);
        filterInput.addEventListener('input', () => renderTable(fullStatusData));

        // Initial load
        fetchStatus();
    </script>
</body>
</html> 